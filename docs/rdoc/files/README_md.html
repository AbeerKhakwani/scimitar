<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.md</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../css/github.css" type="text/css" media="screen" />
<script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>
    <div class="banner">
        <h1>
            README.md
        </h1>
        <ul class="files">
            <li>README.md</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
    <div class="description">
        
<h1 id="label-Scimitar"><a href="../classes/Scimitar.html"><code>Scimitar</code></a></h1>

<p><a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/license-mit-blue.svg"></a></p>

<p>A SCIM v2 API endpoint implementation for Ruby On Rails.</p>

<h2 id="label-Overview">Overview</h2>

<p>System for Cross-domain Identity Management (SCIM) is a protocol that helps systems synchronise user data between different business systems. A <em>service provider</em> hosts a SCIM API endpoint implementation and the <a href="../classes/Scimitar.html"><code>Scimitar</code></a> gem is used to help quickly build this implementation. One or more <em>enterprise subscribers</em> use these APIs to let that service know about changes in the enterprise&#39;s user (employee) list.</p>

<p>In the context of the names used by the SCIM standard, the service that is provided is some kind of software-as-a-service solution that the enterprise subscriber uses to assist with their day to day business. The enterprise maintains its user (employee) list via whatever means it wants, but includes SCIM support so that any third party services it uses can be kept up to date with adds, removals or changes to employee data.</p>
<ul><li>
<p><a href="https://en.wikipedia.org/wiki/System_for_Cross-domain_Identity_Management">Overview</a> at Wikipedia</p>
</li><li>
<p><a href="http://www.simplecloud.info">More detailed introduction</a> at SimpleCloud</p>
</li><li>
<p>SCIM v2 RFC <a href="https://tools.ietf.org/html/rfc7642">7642</a>: Concepts</p>
</li><li>
<p>SCIM v2 RFC <a href="https://tools.ietf.org/html/rfc7643">7643</a>: Core schema</p>
</li><li>
<p>SCIM v2 RFC <a href="https://tools.ietf.org/html/rfc7644">7644</a>: Protocol</p>
</li></ul>

<h2 id="label-Installation">Installation</h2>

<p>Install using:</p>

<pre><code>gem install scimitar
</code></pre>

<p>In your Gemfile:</p>

<pre><code>gem &#39;scimitar&#39;, &#39;~&gt; 1.0&#39;
</code></pre>

<p><a href="../classes/Scimitar.html"><code>Scimitar</code></a> uses <a href="https://semver.org">semantic versioning</a> so you can be confident that patch and minor version updates for features, bug fixes and/or security patches will not break your application.</p>

<h2 id="label-Heritage">Heritage</h2>

<p><a href="../classes/Scimitar.html"><code>Scimitar</code></a> borrows heavily - to the point of cut-and-paste - from:</p>
<ul><li>
<p><a href="https://github.com/Cisco-AMP/scim_engine">ScimEngine</a> for the Rails controllers and resource-agnostic subclassing approach that makes supporting User and/or Group, along with custom resource types if you need them, quite easy.</p>
</li><li>
<p><a href="https://github.com/lessonly/scim_rails">ScimRails</a> for the bearer token support, &#39;index&#39; actions and filter support.</p>
</li><li>
<p><a href="https://github.com/ingydotnet/scim-query-filter-parser-rb">SCIM Query Filter Parser</a> for advanced filter handling.</p>
</li></ul>

<p>All three are provided under the MIT license. <a href="../classes/Scimitar.html"><code>Scimitar</code></a> is too.</p>

<h2 id="label-Usage">Usage</h2>

<p>Some of the stuff to do here:</p>
<ul><li>
<p>Setting up what authentication method you use</p>
</li><li>
<p>Building an example subclass to do basic User operations</p>
</li><li>
<p>How to map to/from your own User records and a Scimitar::User</p>
</li><li>
<p>Likewise, groups</p>
</li><li>
<p>Bulk operations and filters</p>
</li></ul>

<p><a href="../classes/Scimitar.html"><code>Scimitar</code></a> neither enforces nor presumes any kind of encoding for bearer tokens. You can use anything you like, including encoding/encrypting JWTs if you so wish - <a href="https://rubygems.org/gems/jwt">rubygems.org/gems/jwt</a> may be useful. The way in which a client might integrate with your SCIM service varies by client and you will have to check documentation to see how a token gets conveyed to that client in the first place (e.g. a full OAuth flow with your application, or just a static token generated in some UI which an administrator copies and pastes into their client&#39;s SCIM configuration UI).</p>

<h3 id="label-Routes">Routes</h3>

<p>For each resource you support, add these lines to your <code>routes.rb</code>:</p>

<pre><code>namespace :scim do
  mount Scimitar::Engine, at: &#39;/&#39;

  get    &#39;Users&#39;,     to: &#39;users#index&#39;
  get    &#39;Users/:id&#39;, to: &#39;users#show&#39;
  post   &#39;Users&#39;,     to: &#39;users#create&#39;
  put    &#39;Users/:id&#39;, to: &#39;mock_users#replace&#39;
  patch  &#39;Users/:id&#39;, to: &#39;mock_users#update&#39;
  delete &#39;Users/:id&#39;, to: &#39;users#destroy&#39;
end
</code></pre>

<p>All routes then will be available at <code>https://.../scim/...</code>.</p>

<h3 id="label-Controllers">Controllers</h3>

<p>If you do <em>not</em> use ActiveRecord to store data, or if you have very esoteric read-write requirements, you can subclass <code>ScimEngine::ResourcesController</code> in a manner similar to this:</p>

<pre><code>module Scim

  # SCIM clients don&#39;t use Rails CSRF tokens.
  #
  skip_before_action :verify_authenticity_token

  class UsersController &lt; ScimEngine::ResourcesController

    # If you have any filters you need to run BEFORE authentication done in
    # the superclass (typically set up in config/initializers/scimitar.rb),
    # then use &quot;prepend_before_filter to declare these - else Scimitar&#39;s
    # own authorisation before-action filter would always run first.

    def index
      # There&#39;s a degree of heavy lifting for arbitrary storage engines.
      query = if params[:filter].present?
        attribute_map = User.new.scim_queryable_attributes() # Note use of *instance* method
        parser        = Scimitar::Lists::QueryParser.new(attribute_map)

        parser.parse(params[:filter])
        # Then use &#39;parser&#39; to read e.g. #tree or #rpn and turn this into a
        # query object for your storage engine. With ActiveRecord, you could
        # just do: parser.to_activerecord_query(base_scope)
      else
        # Return a query object for &#39;all results&#39; (e.g. User.all).
      end

      # Assuming the &#39;query&#39; object above had ActiveRecord-like semantics,
      # you&#39;d create a Scimitar::Lists::Count object with total count filled in
      # via #scim_pagination_info and obtain a page of results with something
      # like the code shown below.
      pagination_info = scim_pagination_info(query.count())
      page_of_results = query.offset(pagination_info.offset).limit(pagination_info.limit).to_a

      super(pagination_info, page_of_results) do | record |
        # Return each instance as a SCIM object, e.g. via Scimitar::Resources::Mixin#to_scim
        record.to_scim(location: url_for(action: :show, id: record.id))
      end
    end

    def show
      super do |user_id|
        user = find_user(user_id)
        # Evaluate to the record as a SCIM object, e.g. via Scimitar::Resources::Mixin#to_scim
        user.to_scim(location: url_for(action: :show, id: user_id))
      end
    end

    def create
      super do |scim_resource|
        # Create an instance based on the Scimitar::Resources::User in
        # &quot;scim_resource&quot; (or whatever your ::storage_class() defines via its
        # ::scim_resource_type class method).
        record = self.storage_class().new
        record.from_scim!(scim_hash: scim_resource.as_json())
        self.save!(record)
        # Evaluate to the record as a SCIM object (or do that via &quot;self.save!&quot;)
        user.to_scim(location: url_for(action: :show, id: user_id))
      end
    end

    def replace
      super do |record_id, scim_resource|
        # Fully update an instance based on the Scimitar::Resources::User in
        # &quot;scim_resource&quot; (or whatever your ::storage_class() defines via its
        # ::scim_resource_type class method). For example:
        record = self.find_record(record_id)
        record.from_scim!(scim_hash: scim_resource.as_json())
        self.save!(record)
        # Evaluate to the record as a SCIM object (or do that via &quot;self.save!&quot;)
        user.to_scim(location: url_for(action: :show, id: user_id))
      end
    end

    def update
      super do |record_id, patch_hash|
        # Partially update an instance based on the PATCH payload *Hash* given
        # in &quot;patch_hash&quot; (note that unlike the &quot;scim_resource&quot; parameter given
        # to blocks in #create or #replace, this is *not* a high-level object).
        record = self.find_record(record_id)
        record.from_scim_patch!(patch_hash: patch_hash)
        self.save!(record)
        # Evaluate to the record as a SCIM object (or do that via &quot;self.save!&quot;)
        user.to_scim(location: url_for(action: :show, id: user_id))
      end
    end

    def destroy
      super do |user_id|
        user = find_user(user_id)
        user.delete
      end
    end

    protected

      # The class including Scimitar::Resources::Mixin which declares mappings
      # to the entity you return in #resource_type.
      #
      def storage_class
        User
      end

      # Find your user. The +id+ parameter is one of YOUR identifiers, which
      # are returned in &quot;id&quot; fields in JSON responses via SCIM schema. If the
      # remote caller (client) doesn&#39;t want to remember your IDs and hold a
      # mapping to their IDs, then they do an index with filter on their own
      # &quot;externalId&quot; value and retrieve your &quot;id&quot; from that response.
      #
      def find_user(id)
        # Find records by your ID here.
      end

      # Persist &#39;user&#39; - for example, if we *were* using ActiveRecord...
      #
      def save!(user)
        user.save!
      rescue ActiveRecord::RecordInvalid =&gt; exception
        raise Scimitar::ResourceInvalidError.new(record.errors.full_messages.join(&#39;; &#39;))
      end


  end
end
</code></pre>

<p>Note that the <code>Scimitar::ApplicationController</code> parent class of <code>Scimitar::ResourcesController</code> has a few methods to help with handling exceptions and rendering them as SCIM responses; for example, if a resource were not found by ID, you might wish to use <code>Scimitar::ApplicationController#handle_resource_not_found</code>. If you use ActiveRecord, though, you can choose a more advanced subclass and all of that gets handled for you:</p>

<pre><code>module Scim
  class MockUsersController &lt; Scimitar::ActiveRecordBackedResourcesController

    skip_before_action :verify_authenticity_token

    protected

      def storage_class
        User
      end

      def storage_scope
        User.all # Or e.g. &quot;User.where(is_deleted: false)&quot; - whatever base scope you require
      end

  end
end
</code></pre>

<p>In the simplest case - that&#39;s it! All actions are taken via <code>#find</code> or <code>#save!</code>, with things like <code>ActiveRecord::RecordNotFound</code> or generalised SCIM errors handled by the various superclasses.</p>

<pre><code>GREAT

BIG

TO

DO

LIST

OF

STUFF

THAT

NEEDS

TO

GO

HERE

:-)

(I&#39;ll know it once I&#39;ve built it)
</code></pre>

<h2 id="label-Security">Security</h2>

<p>One vital feature of SCIM is its authorisation and security model. The best resource I&#39;ve found to describe this in any detail is <a href="https://tools.ietf.org/html/rfc7644#section-2">section 2 of the protocol RFC, 7644</a>.</p>

<p>Often, you&#39;ll find that bearer tokens are in use by SCIM API consumers, but the way in which this is used by that consumer in practice can vary a great deal. For example, suppose a corporation uses Microsoft Azure Active Directory to maintain a master database of employee details. Azure lets administrators <a href="https://docs.microsoft.com/en-us/azure/active-directory/app-provisioning/how-provisioning-works">connect to SCIM endpoints</a> for services that this corporation might use. In all cases, bearer tokens are used.</p>
<ul><li>
<p>When the third party integration builds an app that it gets hosted in the Azure Marketplace, the token is obtained via full OAuth flow of some kind - the enterprise corporation would sign into your app by some OAuth UI mechanism you provide, which leads to a Bearer token being issued. Thereafter, the Azure system would quote this back to you in API calls via the <code>Authorization</code> HTTP header.</p>
</li><li>
<p>If you are providing SCIM services as part of some wider service offering it might not make sense to go to the trouble of adding all the extra features and requirements for Marketplace inclusion. Fortunately, Microsoft support <a href="https://docs.microsoft.com/en-us/azure/active-directory/app-provisioning/use-scim-to-provision-users-and-groups#integrate-your-scim-endpoint-with-the-aad-scim-client">addition of ‘user-defined’ enterprise “app” integrations</a> in Azure, so the administrator can set up and &#39;provision&#39; your SCIM API endpoint. In <em>this</em> case, the bearer token is just some string that you generate which they paste into the Azure AD UI. Clearly, then, this amounts to little more than a glorified password, but you can take steps to make sure that it&#39;s long, unguessable and potentially be some encrypted/encoded structure that allows you to make additional security checks on “your side” when you unpack the token as part of API request handling.</p>
</li><li>
<p>HTTPS is obviously a given here and localhost integration during development is difficult; perhaps search around for things like POSTman collections to assist with development testing. <a href="../classes/Scimitar.html"><code>Scimitar</code></a> has a reasonably comprehensive internal test suite but it&#39;s only as good as the accuracy and reliability of the subclass code you write to "bridge the gap" between SCIM schema and actions, and your User/Group equivalent records and the operations you perform upon them. Microsoft provide <a href="https://techcommunity.microsoft.com/t5/identity-standards-blog/provisioning-with-scim-design-build-and-test-your-scim-endpoint/ba-p/1204883">additional information</a> to help guide service provider implementors with best practice.</p>
</li></ul>

<h2 id="label-Limitations">Limitations</h2>

<h3 id="label-Specification+versus+implementation">Specification versus implementation</h3>
<ul><li>
<p>The <code>name</code> complex type of a User has <code>givenName</code> and <code>familyName</code> fields which <a href="https://tools.ietf.org/html/rfc7643#section-8.7.1">the RFC 7643 core schema</a> describes as optional. <a href="../classes/Scimitar.html"><code>Scimitar</code></a> marks these as required, in the belief that most user synchronisation scenarios between clients and a Scimitar-based provider would require at least those names for basic user management on the provider side, in conjunction with the in-spec-required <code>userName</code> field. That&#39;s only if the whole <code>name</code> type is given at all - at the top level, this itself remains optional per spec, but if you&#39;re going to bother specifying names at all, <a href="../classes/Scimitar.html"><code>Scimitar</code></a> wants at least those two pieces of data.</p>
</li><li>
<p>Several complex types for User contain the same set of <code>value</code>, <code>display</code>, <code>type</code> and <code>primary</code> fields, all used in synonymous ways. The <code>value</code> field - which is e.g. an e-mail address or phone number - is described as optional by <a href="https://tools.ietf.org/html/rfc7643#section-8.7.1">the RFC 7643 core schema</a>, also using "SHOULD" rather than "MUST" in field descriptions elsewhere. <a href="../classes/Scimitar.html"><code>Scimitar</code></a> marks this as required; there&#39;s no point being sent (say) an e-mail section which has entries that don&#39;t provide the e-mail address! The schema descriptions for <code>display</code> also note that this is something optionally sent by the service provider and says clearly that it is read-only - yet the schema declares it <code>readWrite</code>. <a href="../classes/Scimitar.html"><code>Scimitar</code></a> marks it as read-only in its schema.</p>
</li><li>
<p>The <code>displayName</code> of a Group is described in <a href="https://tools.ietf.org/html/rfc7643#section-4.2">RFC 7643 section 4.2</a> and in the free-text schema <code>description</code> field as required, but the schema nonetheless states <code>&quot;required&quot; : false</code> in the formal definition. We consider this to be an error and mark the property as <code>&quot;required&quot; : true</code>.</p>
</li><li>
<p>In the <code>members</code> section of a <a href="https://tools.ietf.org/html/rfc7643#page-69">Group in the RFC 7643 core schema</a>, any member&#39;s <code>value</code> is noted as <em>not</em> required but <a href="https://tools.ietf.org/html/rfc7643#section-4.2">the RFC also says</a> “Service providers MAY require clients to provide a non-empty value by setting the ”required“ attribute characteristic of a sub-attribute of the ”members“ attribute in the ”Group“ resource schema”. <a href="../classes/Scimitar.html"><code>Scimitar</code></a> does this. The <code>value</code> field would contain the <code>id</code> of a SCIM resource, which is the primary key on “our side” as a service provider. Just as we must store <code>externalId</code> values to maintain a mapping on “our side”, we in turn <em>do</em> require clients to provide our ID in group member lists via the <code>value</code> field.</p>
</li><li>
<p>While the gem attempts to support difficult/complex filter strings via incorporating code and ideas in <a href="https://github.com/ingydotnet/scim-query-filter-parser-rb">SCIM Query Filter Parser</a>, it is possible that ActiveRecord / Rails precedence on some query operations in complex cases might not exactly match the SCIM specification. Please do submit a bug report if you encounter this. You may also wish to view <a href="https://github.com/RIPGlobal/scimitar/blob/main/spec/models/scimitar/lists/query_parser_spec.rb">query_parser_spec.rb</a> to get an idea of the tested examples - more interesting test cases are in the "<code>context &#39;with complex cases&#39; do</code>" section.</p>
</li></ul>

<h3 id="label-Omissions">Omissions</h3>
<ul><li>
<p>Only whole-resource <code>PUT</code> is supported for updates, not the complicated <code>PATCH</code> mechanism. The mandatory former maps very closely to Rails behaviour while the optional latter would require very extensive extra code, especially around multiple operation types and <code>path</code> handling, with its filter-like strings.</p>
</li></ul>

<h2 id="label-Development">Development</h2>

<p>Install dependencies first:</p>

<pre><code>bundle install
</code></pre>

<h3 id="label-Tests">Tests</h3>

<p>The tests use <a href="http://rspec.info">RSpec</a> and require SQLite to be installed on your system. After <code>bundle install</code>, set up the test database with:</p>

<pre><code>pushd spec/apps/dummy
RAILS_ENV=test bundle exec rails db:drop db:create db:migrate
popd
</code></pre>

<p>…and thereafter, run tests with:</p>

<pre><code>bundle exec rspec
</code></pre>

<p>You can get an idea of arising test coverage by opening <code>coverage/index.html</code> in your preferred web browser.</p>

<h3 id="label-Internal+documentation">Internal documentation</h3>

<p>Regenerate the internal <a href="https://ruby-doc.org/stdlib-2.4.1/libdoc/rdoc/rdoc/RDoc/Markup.html#label-Supported+Formats">rdoc documentation</a> with:</p>

<pre><code>bundle exec rake rerdoc
</code></pre>

<p>…yes, that&#39;s <code>rerdoc</code> - Re-R-Doc.</p>

    </div>










<!-- Methods -->
</div>

    </div>
  </body>
</html>
